Design Rationale for Req2: Factory

- In this requirement, there exist an entity in parking lot that will allow player/intern to sell certain items/scraps
  in order for them to make profits out of what they could find from both of the moons.

These following classes were created to assist and developed previous code to make the above requirement possible:

  SellableItem interface:
  All the items that are sellable must implement the SellableItem interface. This class has important methods such as
  getPrice() and sellItem(Actor actor) which would allow any items to perform essential processes but also reduce
  redundant due to interface's re-usability as certain item have varied percentage and effects when being purchase by the
  humanoid figure. In each item class (such as metalSheet, metalPipe, ... etc) additional attribute is added which are
  price (int) and chance (int) if the item has special promotion (both in good and bad ways). Each sellable item's
  getPrice() will simply provide the price of the item if the item doesn't have attribute chance. If the item has chance
  /promotion that associates with the item price, then the item's getPrice() method will have calculate whether the
  chance/promotion is met, if so, chance the price, if not, the price remains the same. In terms of toilet paper where
  intern will instantly by kill by Humanoid figure if chance is met, the implementation of hurting player is instead
  implement in sellItem() method. Initially, this implementation was implemented in getPrice() but due to the main
  responsibility of getPrice() method being to deal with item's price, eliminating the intern shouldn't be related to
  this method at all but instead should be implement Whilst the item is being sold which occurs in sellItem() method
  where it has a responsibility to deal with essential process of selling the item by removing and adding intern's
  balance when an item is sold.

  Sellable enum:
  An enum class for enum "SELLABLE" which can be use as a capability for items to signifies whether the item is sellable.
  It is currently being used in humanoid figure to identify item that are sellable from intern's inventory. Individual
  sellable item will have "SELLABLE" added to their capability. In the future where new sellable item is added, this
  enum can easily be reuse to identify the item as sellable.

  NeutralActor:
  A class for actor that will not be able to be attack by other actor in the game (for now). More explanation is in
  Humanoid figure/below.

  Humanoid figure:
  As Humanoid figure is a type of actor that shouldn't be attack by both intern and other actor such as enemy, Humanoid
  shouldn't be both ENEMY and HOSTILE_TO_ENEMY. A class (neutralActor) is created to represent actor that are neutral to
  both type of actor. Object of this class will inherit a new status which is called "NEUTRAL". Despite Humanoid figure
  already restricted from being attack by other type of actor (due to it not being HOSTILE_TO_ENEMY or ENEMY), I figure
  an additional status should be created to represent those who aren't able to be attack by other actor. By doing so,
  any upcoming actor that will be restrict attack from other actor will utilise "NEUTRAL" as their capability by
  extending neutralActor. Thus, enhancing the code through the use of re-usability. In humanoidFigure class, the process
  in allowableAction method will extract intern's inventory for their item(s). For each item extract from player's
  inventory, the methods will check whether the item is sellable by checking it's capability. If it is SELLABLE,
  interface-casting will occur to change item declaration from Item to SellableItem. This will allow the sellable item
  that was initially declared as Item to utilise essential methods such as getPrice() and sellItem(Actor actor) by
  changing its declaration to SellingItem which it should already implement. By doing this, the item will be compatible
  SellingAction class as they're able to use their SellableItem methods. Afterwards, the newly chagned SellableItem
  object will get pass into SellingAction's constructor parameter which is created everytime a sellable item is found
  in intern's inventory.

  SellingAction:
  In SellingAction, sellableItem, the buyer, and the intern (the seller) will be taken as the class attributes. In
  execute method, the sellable item's sellItem(Actor actor) methods will get called with intern as the method's
  parameter. If the selling process is successful, the text "The intern sold the (the item) for $(the price)." will show
  up whilst If the selling wasn't successful (where the process will check if the seller's health attribute have reached
  0), the text "(the seller) is instantly killed by (the buyer)" will show, then the "YOU ARE FIRED" will show up as the
  game is terminate. For menuDescription method, the method will print out a text which says "Sell (the item)." for the
  intern to select if they want to sell that particular item. In terms of re-usability, this method will works with any
  item objects that has SELLABLE in their capability as well as implementing SellableItem.

  Toilet paper punish: For toilet paper, if the provided chance is met, the player will be killed instantly by the
  humanoid figure. In terms of implementation idea, I assign dealing damage within toilet paper class (as it is its
  passive affects) whilst checking for player's health and provide text "The intern is instantly killed by the humanoid
  figure." in SellingAction (for re-usability). By not associating humanoid figure directly into this process, the code
  will become more versatile as any future actor that will have the ability to buy intern's item will be able to re-use
  code instead of making killing action specifically for themselves which would result in repeating for every actor that
  can buy intern's item.

**
The main reason to why I didn't implement as new Sellable concrete class that has both new price and chance attribute
then implement SellableItem interface. I feared it being down-casting when i interface-cast from Item to SellingItem in
the allowableAction of humanoid figure.
**

Principles:

DRY:

- By creating both interface "SellableItem" and enum "SELLABLE", items that are Sellable will be able to re-use previous
  code/method by override the interface's method and reusing the same enum to both identify themselves as sellable and
  allow them to obtain price, calculate effects on price or the intern and sell the item to humanoid figure.

- NeutralActor class and new status "NEUTRAL" will simply allow any new actor that will be add to the game to implement
  if they will not be able to be attack by other actor which is re-usable and no need to make each new actor class to
  explicitly make themselves Neutral if extends from this existing class.


SRP:
- each newly created class mainly has single own responsibility:
  e.g. - Humanoid figure: produce selling actions for sellable item
       - SellableItem interface: provide getPrice() and sellItem(Actor actor) methods for sellable items to be able to
         provide appropriate price and sell that particular item to buyer (Humanoid figure).
       - Sellable enum: allow the item to be recognise as sellable.
       - NeutralActor: Allow its object/actor to not be attack by any actor.
       - SellingAction: Provoke selling process by activating SellableItem object's sellItem(Actor actor) method. if not
         success (intern died), terminate the game by removing the actor from the map.

OCP:
- the newly created class should be extendable without needing to change its previous code.
- e.g. - Other than Humanoid figure, any future coming actor that will have the ability to not be attack by other actors
         will be able to simply extends the NeutralActor class and add their own function that suits the new actor's
         purposes. This promotes re-usability as well as extendable code as the new class will be able to utilise
         NeutralActor settings/attributes as well as adding new functions/methods.
       - This would also apply to sellableItem where you could add a new function to the interface or if there is a new
         sellable item could simply implement the interface whilst having their functions when it is purchase.

LIP:
- Superclass will still be replaceable by newly created class.
- e.g. - Humanoid figure can replace Actor from NeutralActor.
       - All the sellable item such as metal sheet and so on... can replace item
       - SellingAction can replace Action.

ISP:
- All the newly created class is fully utilising and isn't being force to rely on interface class.
- e.g. all the sellable item are require to  utilising both getPrice() and sellItem(Actor actor) from SellingItem
       interface.

DIP:
- High-level class isn't directly relying on low-level clas but through interface.
- e.g. SellingAction is accessing sellable item classes (Metal sheet again and so on...) through SellableItem interface
       as the items are required to and is implementing the interface.

Dependency injection:
- newly created class accepts object for it parameter.
- e.g. SellingAction accepts SellableItem as their parameter.

Smells:
- Short length of methods: isn't too long.
- No god classes: all the class have their own responsibility instead of having all responsibility to one class.
- short parameter list: at most accepts 2 parameter in both constructor and methods of newly created classes.

Connascence:
-

Pros:
- Maintainable due to each class having single responsibility.
- readable as each method isn't long and is responsible on single purpose.
- Easily extendable when needed as there are classes made to accommodate future possible actors and items.

Cons:
- May be complicated due to single responsibility principle which splits classes resulting in needing a higher level of
  knowledge of coding to learn what's going on.
- May be time consuming to implement all the concepts at first (but ig it's worth it for readability and maintainability)



